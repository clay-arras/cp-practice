{"id":1732792347,"question_id":2652,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1755020723,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1732792347/","is_pending":"Not Pending","title":"Count Number of Possible Root Nodes","memory":"N/A","code":"class Solution {\npublic:\n    const static int MXN = 1e5+1;\n    unordered_map<string, int> proc;\n    vector<pair<int, int>> adj_list[MXN];\n    vector<bool> visited;\n\n    int cnt = 0, ans = 0;\n    int K;\n    void dfs(int s) {\n        visited[s] = true; \n        for (auto x : adj_list[s]) {\n            if (!visited[x.first]) {\n                dfs(x.first);\n                cnt += x.second;\n            }\n        }\n    }\n\n    void dp(int s, int prev) {\n        visited[s] = true; \n        if (s) ans += (prev >= K);\n\n        for (auto x : adj_list[s]) {\n            if (!visited[x.first]) {\n                dp(x.first, prev + (proc[to_string(x.first) + \"#\" + to_string(s)] - \n                                    proc[to_string(s) + \"#\" + to_string(x.first)]));\n            }\n        }\n    }\n\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        // for all N, check if at least k nodes form the special tree\n        // has an easy N * guesses solution, just loop through \n        // insted of looping through N sequentially, traverse the tree. do dfs to find                             \n        // if in one way then 1 point, else 0\n        // if no guess edge then 0\n        // dfs on ONE then use RELATIVE numbering\n        K = k;\n\n        for (auto g : guesses) {\n            adj_list[g[0]].push_back({g[1], 1}); // maybe reverse this???\n            proc[to_string(g[0]) + \"#\" + to_string(g[1])] = 1;\n        }\n        for (auto g : edges) {\n            if (!proc.count(to_string(g[0]) + \"#\" + to_string(g[1])))\n                adj_list[g[0]].push_back({g[1], 0});\n            if (!proc.count(to_string(g[1]) + \"#\" + to_string(g[0])))\n                adj_list[g[1]].push_back({g[0], 0});\n        }\n\n        int N = (int)edges.size() + 1;\n        visited = vector<bool> (N, false);\n\n        dfs(0);\n        ans += (cnt >= k);\n\n        visited = vector<bool> (N, false);\n        visited[0] = true;\n        cout << cnt << endl;\n        dp(0, cnt);\n        \n        return ans;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111110000","title_slug":"count-number-of-possible-root-nodes","has_notes":false,"flag_type":1,"frontend_id":1167}