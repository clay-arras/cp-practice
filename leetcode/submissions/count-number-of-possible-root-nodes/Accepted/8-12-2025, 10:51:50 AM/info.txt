{"id":1732801481,"question_id":2652,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1755021110,"status":10,"status_display":"Accepted","runtime":"294 ms","url":"/submissions/detail/1732801481/","is_pending":"Not Pending","title":"Count Number of Possible Root Nodes","memory":"215.3 MB","code":"class Solution {\npublic:\n    struct PairHash {\n        template <class T1, class T2>\n        std::size_t operator () (const std::pair<T1, T2>& p) const {\n            auto h1 = std::hash<T1>{}(p.first);\n            auto h2 = std::hash<T2>{}(p.second);\n            return h1 ^ (h2 << 1); \n        }\n    };\n\n    const static int MXN = 1e5+1;\n    unordered_map<pair<int, int>, int, PairHash> proc;\n    vector<pair<int, int>> adj_list[MXN];\n    vector<bool> visited;\n\n    int cnt = 0, ans = 0;\n    int K;\n    void dfs(int s) {\n        visited[s] = true; \n        for (auto x : adj_list[s]) {\n            if (!visited[x.first]) {\n                dfs(x.first);\n                cnt += x.second;\n            }\n        }\n    }\n\n    void dp(int s, int prev) {\n        visited[s] = true; \n        if (s) ans += (prev >= K);\n\n        for (auto x : adj_list[s]) {\n            if (!visited[x.first]) {\n                int sum = 0;\n                sum += proc.count({x.first, s});\n                sum -= proc.count({s, x.first});\n                dp(x.first, prev + sum);\n            }\n        }\n    }\n\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        K = k;\n\n        for (auto g : guesses) {\n            adj_list[g[0]].push_back({g[1], 1}); // maybe reverse this???\n            proc[{g[0], g[1]}] = 1;\n        }\n        for (auto g : edges) {\n            if (!proc.count({g[0], g[1]}))\n                adj_list[g[0]].push_back({g[1], 0});\n            if (!proc.count({g[1], g[0]}))\n                adj_list[g[1]].push_back({g[0], 0});\n        }\n\n        int N = (int)edges.size() + 1;\n        visited = vector<bool> (N, false);\n\n        dfs(0);\n        ans += (cnt >= k);\n\n        visited = vector<bool> (N, false);\n        visited[0] = true;\n        dp(0, cnt);\n        \n        return ans;\n    }\n};\n\n/*\npattern for these tree questions w/ edge reversals: do edge adj_list w/ weights of 1 or 0 depending on if its in that direction. then do a single dfs/dp using one node as a reference then doing relative calculations\nsimilar to https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable/\n\n*/","compare_result":"1111111111111111111111111111111111111111111111111111","title_slug":"count-number-of-possible-root-nodes","has_notes":false,"flag_type":1,"frontend_id":1169}