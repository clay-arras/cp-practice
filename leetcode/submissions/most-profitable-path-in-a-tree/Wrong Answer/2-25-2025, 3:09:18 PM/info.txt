{"id":1555470954,"question_id":2564,"lang":"cpp","lang_name":"C++","time":"8 months, 3 weeks","timestamp":1740524958,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1555470954/","is_pending":"Not Pending","title":"Most Profitable Path in a Tree","memory":"N/A","code":"class Solution {\npublic:\n    const static int MX = 1e5+9;\n    vector<int> adj_list[MX];\n    vector<bool> visited;\n\n    template<class T>\n    vector<T> BFS(T src, int N, vector<int>& path, vector<int>& amount) {\n        const T mxV = 1e9+9;\n        queue<int> q;\n        vector<T> dist(N, mxV);\n        vector<int> income(N, 0);\n\n        dist[src] = 0;\n        q.push(src);\n        int timestep = -1;\n        while (!q.empty()) {\n\n            int x = q.front();\n\n            if (timestep < dist[x]) {\n                timestep = dist[x]; \n                cout << timestep << endl;\n                if (timestep < (int)path.size()) {\n                    if (path[timestep] == x) \n                        amount[x] /= 2;\n                    else amount[path[timestep]] = 0;\n                }\n            }\n            income[x] += amount[x];\n            \n            q.pop();\n            for (int t : adj_list[x]) {\n                if (dist[t] == mxV) {\n                    dist[t] = dist[x] + 1;\n                    income[t] = income[x];\n                    q.push(t);\n                }\n            }\n        }\n        return income;\n    }\n\n    vector<int> dfs(int s) {\n        visited[s] = true;\n        if (s == 0)  return {s};\n\n        for (int i : adj_list[s]) {\n            if (!visited[i]) {\n                vector<int> val = dfs(i);\n                if (val != vector<int>()) {\n                    val.push_back(s);\n                    return val;\n                }\n            }\n        }\n        return vector<int>();\n    }\n\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\n        // bfs\n        // at each depth, figure out which node bob is going to. \n        // 2 cases: either its the same OR its completely different path (Alice and Bob meet at MOST once)\n        // either way, we DIRECTLY modify the tree values\n        int N = (int)amount.size();\n\n        for (auto e : edges) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n\n        visited = vector<bool> (N, false);\n        vector<int> path = dfs(bob);\n        reverse(path.begin(), path.end()); // path[i] is the node BOB is on at timestep i\n\n        vector<int> ans = BFS<int>(0, N, path, amount);\n        int mxVal = -INT_MAX;\n        for (int i=0; i<N; i++) {\n            if ((int)adj_list[i].size() == 1)\n                mxVal = max(mxVal, ans[i]);\n        }\n\n        return mxVal;\n    }\n};","compare_result":"1110111011111111111111111110111","title_slug":"most-profitable-path-in-a-tree","has_notes":false,"flag_type":1,"frontend_id":1021}