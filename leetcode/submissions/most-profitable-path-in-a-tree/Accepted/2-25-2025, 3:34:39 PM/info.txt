{"id":1555482807,"question_id":2564,"lang":"cpp","lang_name":"C++","time":"8 months, 3 weeks","timestamp":1740526479,"status":10,"status_display":"Accepted","runtime":"191 ms","url":"/submissions/detail/1555482807/","is_pending":"Not Pending","title":"Most Profitable Path in a Tree","memory":"206 MB","code":"class Solution {\npublic:\n    const static int MX = 1e5+9;\n    vector<int> adj_list[MX];\n    vector<bool> visited;\n\n    template<class T>\n    vector<T> BFS(T src, int N, vector<int>& path, vector<int>& amount) {\n        const T mxV = 1e17+9;\n        queue<int> q;\n        vector<T> dist(N, mxV);\n        vector<long long> income(N, 0);\n\n        dist[src] = 0;\n        q.push(src);\n        int timestep = -1;\n        while (!q.empty()) {\n            int x = q.front();\n\n            if (timestep < dist[x]) {\n                timestep = dist[x]; \n                if (timestep < (int)path.size()) {\n                    bool anyInLevel = false;\n                    queue<int> tmpQ = q;\n                    int p = q.front();\n                    while (!tmpQ.empty() && dist[p] == dist[x]) {\n                        anyInLevel |= (path[timestep] == p);\n                        tmpQ.pop();\n                        if (tmpQ.empty())\n                            break;\n                        p = tmpQ.front();\n                        assert(dist[p] >= dist[x]);\n                    }\n\n                    if (anyInLevel)\n                        amount[path[timestep]] /= 2;\n                    else amount[path[timestep]] = 0;\n                }\n            }\n            income[x] += amount[x];\n            \n            q.pop();\n            for (int t : adj_list[x]) {\n                if (dist[t] == mxV) {\n                    dist[t] = dist[x] + 1;\n                    income[t] = income[x];\n                    q.push(t);\n                }\n            }\n        }\n        return income;\n    }\n\n    vector<int> dfs(int s) {\n        visited[s] = true;\n        if (s == 0)  return {s};\n\n        for (int i : adj_list[s]) {\n            if (!visited[i]) {\n                vector<int> val = dfs(i);\n                if (val != vector<int>()) {\n                    val.push_back(s);\n                    return val;\n                }\n            }\n        }\n        return vector<int>();\n    }\n\n    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {\n        int N = (int)amount.size();\n        for (auto e : edges) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n\n        visited = vector<bool> (N, false);\n        vector<int> path = dfs(bob);\n        reverse(path.begin(), path.end());\n\n        vector<long long> ans = BFS<long long>(0, N, path, amount);\n        long long mxVal = -LLONG_MAX;\n        for (int i=1; i<N; i++) {\n            if ((int)adj_list[i].size() == 1)\n                mxVal = max(mxVal, ans[i]);\n        }\n\n        return mxVal;\n    }\n};","compare_result":"1111111111111111111111111111111","title_slug":"most-profitable-path-in-a-tree","has_notes":false,"flag_type":1,"frontend_id":1024}