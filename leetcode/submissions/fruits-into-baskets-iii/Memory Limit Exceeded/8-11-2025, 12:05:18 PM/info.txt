{"id":1731662462,"question_id":3791,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754939118,"status":12,"status_display":"Memory Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1731662462/","is_pending":"Not Pending","title":"Fruits Into Baskets III","memory":"N/A","code":"class Solution {\npublic:\n    template<class T>\n    struct SegTree {\n        static constexpr T unit = {INT_MAX, -1};\n        T f(T a, T b) { return min(a, b); }\n        vector<T> tree; int n;\n        SegTree (int i = 0, T def = unit) : tree(2*i, def), n(i) {}\n        void update(int pos, T val) {\n            for (tree[pos += n] = val; pos /= 2;)\n                tree[pos] = f(tree[pos * 2], tree[pos * 2 + 1]);\n        }\n        T query(int b, int e) {\n            T ra = unit, rb = unit;\n            for (b += n, e += n; b < e; b /= 2, e /= 2) {\n                if (b % 2) ra = f(ra, tree[b++]);\n                if (e % 2) rb = f(tree[--e], rb);\n            }\n            return f(ra, rb);\n        }\n    };\n\n    int numOfUnplacedFruits(vector<int>& fruits, vector<int>& baskets) {\n        int N = (int)baskets.size();\n        int mxV = *max_element(baskets.begin(), baskets.end());\n\n        SegTree<pair<int, int>> s(mxV+1);\n        unordered_map<int, priority_queue<int>> m; // baskets[i], {-i...}\n        for (int i=0; i<N; i++) \n            m[baskets[i]].push(-i);\n\n        for (auto& [k, v] : m) {\n            if (!v.empty()) {\n                s.update(k, {-v.top(), k}); // baskets[i], {i, baskets[i]}\n                v.pop();\n            }\n        }\n\n        int ans = 0;\n        for (int f : fruits) {\n\n            auto val = s.query(f, mxV+1); // {i, baskets[i]}\n            cout << val.first << \" \" << val.second << endl;;\n            if (val.first == INT_MAX) {\n                ans += 1;\n                continue;\n            }\n            if (m[val.second].empty()) {\n                s.update(val.second, {INT_MAX, val.second});\n            } else {\n                s.update(val.second, {-m[val.second].top(), val.second});\n                m[val.second].pop();\n            }\n        }\n\n        return ans;\n\n        // set<pair<int, int>> s;\n\n        // for (int i=0; i<N; i++) {\n        //     s.insert({baskets[i], i});\n        // }\n        // int ans = 0;\n        // for (int f : fruits) {\n        //     auto it = s.lower_bound({f, -1});\n        //     cout << it->first << \" \" << it->second << endl;\n        //     if (it == s.end()) {\n        //         ans += f;\n        //         continue;\n        //     }\n        //     s.erase(it); \n        // }\n        // return ans;\n        // segment tree w/ min. idx = capacity, val = idx. range query (minCap, end), then remove value from segTree\n    }\n\n    /*\n\ntree = \n\n{{first = 2147483647, second = -1}, \n{first = 0, second = 3}, \n{first = 0, second = 3}, \n{first = 2147483647, second = -1}, \n{first = 0, second = 3}, \n{first = 1, second = 5}, \n{first = 2147483647, second = -1}, \n{first = 2147483647, second = -1}, \n{first = 2147483647, second = -1}, \n{first = 0, second = 3}, \n{first = 2, second = 4}, \n{first = 1, second = 5}}, \nn = 6}\n\n    */\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000","title_slug":"fruits-into-baskets-iii","has_notes":false,"flag_type":1,"frontend_id":1165}