{"id":1731516512,"question_id":2627,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754932180,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1731516512/","is_pending":"Not Pending","title":"Difference Between Maximum and Minimum Price Sum","memory":"N/A","code":"class Solution {\npublic:\n    const static int MX = 1e5+5;\n    int N;\n    vector<int> adj_list[MX];\n    vector<int> p;\n    vector<bool> vis;\n    vector<int> state;\n    vector<pair<int, int>> memo; // cost of path, diameter node\n    unordered_map<int, int> diam; // cost from node to root of diam\n\n    pair<int, int> furth; // dist, node\n    void dfs1(int s, int dist) {\n        vis[s] = true;\n        furth = max(furth, {dist, s});\n        for (int i : adj_list[s]) {\n            if (!vis[i])\n                dfs1(i, dist+p[i]);\n        }\n    }\n\n    bool dfs2(int s, int dist, int ed) {\n        vis[s] = true;\n        bool ok = (s == ed);\n        for (int i : adj_list[s]) {\n            if (!vis[i])\n                ok |= dfs2(i, dist + p[i], ed);\n        }\n        if (ok) diam[s] = dist;\n        return ok;\n    }\n\n    pair<int, int> dp(int s) {\n        if (state[s] == 2)\n            return memo[s];\n        if (state[s] == 1)\n            return {1e9, -1};\n        if (diam.count(s))\n            return memo[s] = {0, s};\n        \n        state[s] = 1;\n\n        pair<int, int> curr = {1e9, -1};\n        for (int i : adj_list[s]) {\n            auto tmp = dp(i);\n            curr = min(curr, {tmp.first + p[s], tmp.second});\n        }\n        state[s] = 2;\n        if (curr == pair<int, int>{1e9, -1})\n            state[s] = 0;\n        return memo[s] = curr;\n    }\n\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\n        N = n;\n        p = price;\n        for (auto e : edges) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n        vis = vector<bool>(n, false);\n        furth = {-1, -1};\n        dfs1(0, p[0]);\n        int st = furth.second;\n\n        vis = vector<bool>(n, false);\n        furth = {-1, -1};\n        dfs1(st, p[st]);\n        int ed = furth.second;\n\n        vis = vector<bool>(n, false);\n        dfs2(st, p[st], ed);\n\n        memo = vector<pair<int, int>>(n, {1e9, -1});\n        state = vector<int> (n, 0);\n        for (int i=0; i<N; i++)\n            dp(i);\n\n        int ans = 0;\n        for (int i=0; i<N; i++) {\n            int sum = memo[i].first;\n            assert(diam.count(memo[i].second));\n            int l = diam[memo[i].second];\n            int r = diam[ed] - diam[memo[i].second] + p[i];\n            ans = max(ans, max(l, r) - p[i]);\n        }\n        return ans;\n    }\n    /*\n        dp where dp[i] is the highest price path starting at root node i\n        how to do transitions? \n\n        slip 1: assume that we are rooting at any N (O(N))\n        need to search in O(logN) or preprocess\n        arr [i] containing the highest price paths starting at root node i\n\n        assertion: if path from a -> b is longest for root node a, is it longest for root node b? ; FALSE\n        assertion: the highest cost path is ALWAYS on the diameter of the tree ; TT\n\n        an array that has the distance of any point on the diameter to the root of the diameter ; to calculate diameter contribution\n        an array that is the distance from the root node to the nearest path on diameter, and which node it is ; CAN DP over this\n        set of all nodes inside the path. if already on the path then 0. \n        \n        finally loop over any N \n        assertion: the highest cost path always ENDS on the diameter of the tree ; TRUE\n    */\n};","compare_result":"1111111111111111111111111110111110101011111111111111111110","title_slug":"difference-between-maximum-and-minimum-price-sum","has_notes":false,"flag_type":1,"frontend_id":1160}