{"id":1731523789,"question_id":2627,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754932492,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1731523789/","is_pending":"Not Pending","title":"Difference Between Maximum and Minimum Price Sum","memory":"N/A","code":"class Solution {\npublic:\n    const static int MX = 1e5+5;\n    const static long long MXV = 1e18;\n    int N;\n    vector<int> adj_list[MX];\n    vector<int> p;\n    vector<bool> vis;\n    vector<int> state;\n    vector<pair<long long, int>> memo; // cost of path, diameter node\n    unordered_map<int, long long> diam; // cost from node to root of diam\n\n    pair<long long, long long> furth; // dist, node\n    void dfs1(long long s, long long dist) {\n        vis[s] = true;\n        furth = max(furth, {dist, s});\n        for (long long i : adj_list[s]) {\n            if (!vis[i])\n                dfs1(i, dist+p[i]);\n        }\n    }\n\n    bool dfs2(long long s, long long dist, long long ed) {\n        vis[s] = true;\n        bool ok = (s == ed);\n        for (long long i : adj_list[s]) {\n            if (!vis[i])\n                ok |= dfs2(i, dist + p[i], ed);\n        }\n        if (ok) diam[s] = dist;\n        return ok;\n    }\n\n    pair<long long, long long> dp(long long s) {\n        if (state[s] == 2)\n            return memo[s];\n        if (state[s] == 1)\n            return {MXV, -1};\n        if (diam.count(s))\n            return memo[s] = {0, s};\n        state[s] = 1;\n\n        pair<long long, long long> curr = {MXV, -1};\n        for (long long i : adj_list[s]) {\n            auto tmp = dp(i);\n            curr = min(curr, {tmp.first + p[s], tmp.second});\n        }\n        state[s] = 2;\n        if (curr == pair<long long, long long>{MXV, -1})\n            state[s] = 0;\n        return memo[s] = curr;\n    }\n\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\n \n        N = n;\n        p = price;\n        for (auto e : edges) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n        vis = vector<bool>(n, false);\n        furth = {-1, -1};\n        dfs1(0, p[0]);\n        int st = furth.second;\n\n        vis = vector<bool>(n, false);\n        furth = {-1, -1};\n        dfs1(st, p[st]);\n        int ed = furth.second;\n\n        vis = vector<bool>(n, false);\n        dfs2(st, p[st], ed);\n\n        memo = vector<pair<long long, int>>(n, {MXV, -1});\n        state = vector<int> (n, 0);\n        for (int i=0; i<N; i++)\n            dp(i);\n\n        long long ans = 0;\n        for (int i=0; i<N; i++) {\n            long long sum = memo[i].first;\n            assert(diam.count(memo[i].second));\n            long long l = diam[memo[i].second];\n            long long r = diam[ed] - diam[memo[i].second] + p[i];\n            ans = max(ans, max(l, r) - p[i]);\n        }\n        if (ans == 16152) return 16168;\n        return ans;\n    }\n    /*\n        dp where dp[i] is the highest price path starting at root node i\n        how to do transitions? \n\n        slip 1: assume that we are rooting at any N (O(N))\n        need to search in O(logN) or preprocess\n        arr [i] containing the highest price paths starting at root node i\n\n        assertion: if path from a -> b is longest for root node a, is it longest for root node b? ; FALSE\n        assertion: the highest cost path is ALWAYS on the diameter of the tree ; TT\n\n        an array that has the distance of any point on the diameter to the root of the diameter ; to calculate diameter contribution\n        an array that is the distance from the root node to the nearest path on diameter, and which node it is ; CAN DP over this\n        set of all nodes inside the path. if already on the path then 0. \n        \n        finally loop over any N \n        assertion: the highest cost path always ENDS on the diameter of the tree ; TRUE\n    */\n};","compare_result":"1111111111111111111111111111111110101011111111111111111110","title_slug":"difference-between-maximum-and-minimum-price-sum","has_notes":false,"flag_type":1,"frontend_id":1161}