{"id":1778714507,"question_id":3928,"lang":"cpp","lang_name":"C++","time":"1 month, 3 weeks","timestamp":1758517894,"status":10,"status_display":"Accepted","runtime":"1683 ms","url":"/submissions/detail/1778714507/","is_pending":"Not Pending","title":"Split and Merge Array Transformation","memory":"427.5 MB","code":"class Solution {\npublic:\n    string n1, n2;\n    int N;\n\n    vector<string> split(string s, int l, int r) {\n        string pref = s.substr(0, l);\n        string sl   = s.substr(l, r - l);\n        string suff = s.substr(r);\n        return {pref, sl, suff};\n    }\n    vector<string> split(string s, int i) {\n        return {s.substr(0, i), s.substr(i)};\n    }\n\n    // NOTE: dp from the original is NOT used anymore for correctness.\n    // The bug was context-dependent memoization. We switch to bestDepth.\n    unordered_map<string, int> bestDepth; // state -> smallest depth seen so far\n    int bestAns;                          // global best (# moves)\n\n    void dfsDepth(const string& arr, int depth) {\n        if (depth >= bestAns) return; // branch-and-bound (we already have a better answer)\n        auto it = bestDepth.find(arr);\n        if (it != bestDepth.end() && it->second <= depth) return; // no improvement\n        bestDepth[arr] = depth;\n\n        if (arr == n2) { bestAns = depth; return; }\n\n        for (int l = 0; l < N; ++l) {\n            for (int r = l + 1; r <= N; ++r) {            // disallow empty removal\n                auto s = split(arr, l, r);                 // s[0]=pref, s[1]=mid, s[2]=suff\n                string c = s[0] + s[2];                    // remaining after removal\n                for (int i = 0; i <= (int)c.size(); ++i) {\n                    if (i == (int)s[0].size()) continue;   // skip no-op reinsertion\n                    auto ins = split(c, i);\n                    string nxt = ins[0] + s[1] + ins[1];\n                    dfsDepth(nxt, depth + 1);\n                }\n            }\n        }\n    }\n\n    int minSplitMerge(vector<int>& nums1, vector<int>& nums2) {\n        N = (int)nums1.size();\n\n        // per request: store input midway\n        auto donquarist = nums1;\n\n        // same encoding as your code (safe for N <= 6: single-digit labels)\n        unordered_map<int, int> m;\n        n1.clear(); n2.clear();\n        for (int i = 0; i < N; i++) {\n            if (!m.count(nums1[i])) m[nums1[i]] = i + 1;\n            n1 += to_string(m[nums1[i]]);\n        }\n        for (int i = 0; i < N; i++)\n            n2 += to_string(m[nums2[i]]);\n\n        if (n1 == n2) return 0;\n\n        bestDepth.clear();\n        bestAns = 6;              // upper bound for n <= 6\n        dfsDepth(n1, 0);\n        return bestAns;\n    }\n};\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"split-and-merge-array-transformation","has_notes":false,"flag_type":1,"frontend_id":1204}