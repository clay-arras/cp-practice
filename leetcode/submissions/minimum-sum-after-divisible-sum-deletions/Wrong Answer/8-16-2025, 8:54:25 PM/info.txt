{"id":1738060402,"question_id":3966,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1755402865,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1738060402/","is_pending":"Not Pending","title":"Minimum Sum After Divisible Sum Deletions","memory":"N/A","code":"class Solution {\npublic:\n    long long minArraySum(vector<int>& nums, int k) {\n        // dp? \n        // feels like a stack esque type of problem, where if any PREFIX of the previous values is divisible by k then we REMOVE the whole prefix (pop until we hit that prefix)\n        const int MXV = 2e9+9;\n\n        int N = (int)nums.size();\n        vector<int> pref(N+1, 0);\n        for (int i=1; i<=N; i++) {\n            pref[i] = (pref[i-1] + nums[i-1]) % k;\n        }\n        vector<int> mod(k, MXV), dp(N, MXV);\n\n        dp[0] = (pref[1] % k ? nums[0] : 0);\n        mod[pref[1]] = 0;\n        for (int i=1; i<N; i++) {\n            dp[i] = dp[i-1] + nums[i]; \n            if (pref[i+1] == 0) {\n                dp[i] = 0;\n                continue;\n            }\n                \n            int idx = mod[pref[i+1]];\n            if (idx != MXV) {\n                dp[i] = min(dp[i], dp[idx]);\n            }\n            mod[pref[i+1]] = min(i, mod[pref[i+1]]);\n        }\n        return dp[N-1];\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110111111111111111111111111111111110111111111111110111101111111110111110111110111111000101101110111011101011111011101111011110111111111111100110111110101010111101110111111010100011010111110110000011011011110110100000011111100000101111101110110011001110101101010111010001100010110000011000101110101100001111111000000000000000","title_slug":"minimum-sum-after-divisible-sum-deletions","has_notes":false,"flag_type":1,"frontend_id":1182}