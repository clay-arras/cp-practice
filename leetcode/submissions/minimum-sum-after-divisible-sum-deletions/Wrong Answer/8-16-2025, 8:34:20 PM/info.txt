{"id":1738034277,"question_id":3966,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1755401660,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1738034277/","is_pending":"Not Pending","title":"Minimum Sum After Divisible Sum Deletions","memory":"N/A","code":"class Solution {\npublic:\n    long long minArraySum(vector<int>& nums, int k) {\n        // dp? \n        // feels like a stack esque type of problem, where if any PREFIX of the previous values is divisible by k then we REMOVE the whole prefix (pop until we hit that prefix)\n\n        int N = (int)nums.size();\n        vector<int> pref(N+1, 0);\n        for (int i=1; i<=N; i++) {\n            pref[i] = pref[i-1] + nums[i-1];\n        }\n        vector<int> mod(k, INT_MAX), dp(N, INT_MAX);\n\n        dp[0] = (nums[0] % k ? nums[0] : 0);\n        mod[pref[1]%k] = 0;\n        for (int i=1; i<N; i++) {\n            dp[i] = dp[i-1] + nums[i]; \n            if (pref[i+1]%k == 0) {\n                dp[i] = 0;\n                continue;\n            }\n                \n            int idx = mod[pref[i+1]%k];\n            if (idx != INT_MAX) {\n                dp[i] = min(dp[i], dp[i-idx]);\n            }\n            mod[pref[i+1]%k] = min(i, mod[pref[i+1]%k]);\n        }\n\n        return dp[N-1];\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111011111111111111111111101111111111101111111111111111111111111111111111111111111111111111111111111111001111101101110111101111110101100000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000001000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"minimum-sum-after-divisible-sum-deletions","has_notes":false,"flag_type":1,"frontend_id":1181}