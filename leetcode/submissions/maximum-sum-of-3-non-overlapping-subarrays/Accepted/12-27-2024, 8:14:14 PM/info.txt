{"id":1490314184,"question_id":689,"lang":"cpp","lang_name":"C++","time":"10 months, 3 weeks","timestamp":1735359254,"status":10,"status_display":"Accepted","runtime":"222 ms","url":"/submissions/detail/1490314184/","is_pending":"Not Pending","title":"Maximum Sum of 3 Non-Overlapping Subarrays","memory":"34 MB","code":"class Solution {\npublic:\n    template<class T>\n    struct RMQ {\n        vector<T> v; vector<vector<int>> jmp;\n        int level(int x) { return 31-__builtin_clz(x); }\n        int cmb(int a, int b) {\n            if (v[a] == v[b])\n                return min(a, b);\n            return v[a] > v[b] ? a : b;\n        }\n        void init(const vector<T>& _v) {\n            int sz = (int)_v.size();\n            jmp = { vector<int>(sz) };\n            v = _v;\n            iota(jmp[0].begin(), jmp[0].end(), 0);\n            for (int j=1; (1<<j)<=sz; j++) {\n                jmp.push_back(vector<int>(sz-(1<<j)+1));\n                for (int i=0; i<(int)jmp[j].size(); i++)\n                    jmp[j][i] = cmb(jmp[j-1][i], jmp[j-1][i+(1<<(j-1))]);\n            }\n        }\n        int index(int l, int r) {\n            assert(l <= r);\n            int d = level(r-l+1);\n            return cmb(jmp[d][l], jmp[d][r-(1<<d)+1]);\n        }\n        T query(int l, int r) { return v[index(l,r)]; }\n    };\n\n    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {\n        int N = (int)nums.size();\n        vector<int> pref(N-k+1);\n\n        int sum = 0;\n        for (int i=0; i<N; i++) {\n            sum += nums[i];\n            if (i >= k-1) {\n                pref[i-k+1] = sum;\n                sum -= nums[i-k+1];\n            }\n        }\n        RMQ<int> spt;\n        spt.init(pref);\n\n        for (int i : pref)\n            cout << i << \" \" ;\n        cout << endl;\n        \n        int ans = 0;\n        vector<int> ret = {INT_MAX, INT_MAX, INT_MAX};\n        for (int i=k; i<=N-2*k; i++) {\n            int l = spt.index(0, i-k);\n            int r = spt.index(i+k, N-k);\n            if (pref[i] + pref[l] + pref[r] == ans) {\n                ret = min(ret, {l, i, r});\n            } else if (pref[i] + pref[l] + pref[r] > ans) {\n                ans = pref[i] + pref[l] + pref[r];\n                ret = {l, i, r};\n            }\n        }\n\n        return ret;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111","title_slug":"maximum-sum-of-3-non-overlapping-subarrays","has_notes":false,"flag_type":1,"frontend_id":997}