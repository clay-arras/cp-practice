{"id":1725044438,"question_id":1389,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754443814,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1725044438/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution {\npublic:\n    struct DSU {\n        vector<int> e;\n        void init(int N) {\n            e = vector<int>(N,-1);\n        }\n        int get(int x) {\n            if (e[x] < 0)\n                return x;\n            return e[x] = get(e[x]);\n        }\n        int size(int x) {\n            return -e[get(x)];\n        }\n        bool unite(int x, int y) {\n            x = get(x), y = get(y);\n            if (x == y)\n                return 0;\n            if (e[x] > e[y])\n                swap(x,y);\n            e[x] += e[y];\n            e[y] = x;\n            return 1;\n        }\n    };\n\n    int N, M;\n    vector<vector<char>> g;\n    vector<vector<bool>> visited;\n    vector<vector<DSU>> ds;\n    pair<int, int> bpos, spos, tpos;\n\n    int tto(int m, int n) { return m*N + n;  }\n    pair<int, int> ott(int i) { return {i / N, i % N};  }\n\n    vector<int> dx = {0, 1, 0, -1};\n    vector<int> dy = {1, 0, -1, 0};\n\n    // assume you can walk though T\n    void dfs(int i, int j, DSU& d) {\n        visited[i][j] = true;\n\n        for (int k=0; k<4; k++) {\n            int x = i + dx[k], y = j + dy[k];  \n            if (x >= 0 && x < M && y >= 0 && y < N && !visited[x][y] && g[x][y] != '#') {\n                d.unite(tto(i, j), tto(x, y));\n                dfs(x, y, d);\n            }\n        }\n    }\n    vector<vector<unordered_map<int, int>>> memo;\n    // state: position of the box, region of the person (map) -> total pushes\n    int dp(int i, int j, int ci, int cj) { // worst case box splits into 4 positions\n        int leader = ds[i][j].get(tto(ci, cj));\n        if (memo[i][j].count(leader))\n            return memo[i][j][leader]; \n        if (i == bpos.first && j == bpos.second) // base case\n            return memo[i][j][leader] = 0;\n        \n        int ans = INT_MAX;\n        for (int k=0; k<4; k++) {\n            int bx = i + dx[k], by = j + dy[k];   // where it was previously\n            int x = i + 2*dx[k], y = j + 2*dy[k];  // where s was previously\n            if (x >= 0 && x < M && y >= 0 && y < N && \n                    g[x][y] != '#' && leader == ds[i][j].get(tto(bx, by))) {\n                ans = min(ans, dp(bx, by, x, y) + 1);\n            }\n        }\n        return memo[i][j][leader] = ans;\n    }\n        \n    int minPushBox(vector<vector<char>>& grid) {\n        // idea: disjoint set union, to figure out connected spaces\n        // simplification: assume guy can teleport anywhere. in that case, it would be a simple graph search. connect node A to node B if there's a space behind it.\n\n        M = (int)grid.size();\n        N = (int)grid[0].size();\n        g = grid;\n\n        ds = vector<vector<DSU>> (M, vector<DSU> (N));\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (grid[i][j] != '#') {\n                    ds[i][j].init(tto(M, N));\n                    char orig = grid[i][j];\n                    grid[i][j] = '#';\n\n                    visited = vector<vector<bool>>(M, vector<bool>(N, false));\n                    // flood fill\n                    dfs(i, j, ds[i][j]);\n                    grid[i][j] = orig;\n                }\n                if (grid[i][j] == 'S')\n                    spos = {i, j};\n                if (grid[i][j] == 'B')\n                    bpos = {i, j};\n                if (grid[i][j] == 'T')\n                    tpos = {i, j};\n            }\n        }\n        memo = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n        int ret = dp(tpos.first, tpos.second, spos.first, spos.second);\n        return (ret == INT_MAX ? -1 : ret);\n    }\n};","compare_result":"000000000000000000000000000000","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1,"frontend_id":1139}