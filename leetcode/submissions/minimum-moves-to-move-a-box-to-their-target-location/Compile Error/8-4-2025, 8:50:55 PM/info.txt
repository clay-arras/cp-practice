{"id":1723822671,"question_id":1389,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754365855,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1723822671/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution {\npublic:\n    int N, M;\n    vector<vector<char>> g;\n\n    int tto(int m, int n) {\n        return m*N + n; \n    }\n    pair<int, int> ott(int i) {\n        return {i / N, i % N}; \n    }\n\n    struct DSU {\n        vector<int> e;\n        void init(int N) {\n            e = vector<int>(N,-1);\n        }\n        int get(int x) {\n            if (e[x] < 0)\n                return x;\n            return e[x] = get(e[x]);\n        }\n        int size(int x) {\n            return -e[get(x)];\n        }\n        bool unite(int x, int y) {\n            x = get(x), y = get(y);\n            if (x == y)\n                return 0;\n            if (e[x] > e[y])\n                swap(x,y);\n            e[x] += e[y];\n            e[y] = x;\n            return 1;\n        }\n    };\n    // assume you can walk though T\n\n    void dfs()\n        \n    int minPushBox(vector<vector<char>>& grid) {\n        // is there ever a situation where the position of the player matters in the state\n        // i.e. pushing the box splits the area into two spaces.\n        // answer: need to keep track of player position then??? or just space-wise, need to keep track of where they are.\n\n        // idea: disjoint set union, to figure out connected spaces\n\n        // simplification: assume guy can teleport anywhere. in that case, it would be a simple graph search. connect node A to node B if there's a space behind it.\n\n        // dp\n        // state: position of the box, region of the person (map) -> total pushes\n\n        // first loop: for every position of the box, figure out which distinct spaces exist. i.e. 400 DSUs\n\n        M = (int)grid.size();\n        N = (int)grid[0].size();\n        g = grid;\n\n        vector<vector<DSU>> ds(M, vector<DSU> (N));\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (grid[i][j] != '#') {\n                    ds[i][j].init(tto(M, N));\n                    char orig = grid[i][j];\n                    grid[i][j] = '#';\n                    // flood fill\n\n                    grid[i][j] = orig;\n                }\n            }\n        }\n    }\n};","compare_result":null,"title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1,"frontend_id":1137}