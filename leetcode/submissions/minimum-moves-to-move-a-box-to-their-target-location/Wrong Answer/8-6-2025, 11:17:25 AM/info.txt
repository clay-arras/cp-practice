{"id":1726049032,"question_id":1389,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754504245,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1726049032/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution {\npublic:\n    struct DSU {\n        vector<int> e;\n        void init(int N) {\n            e = vector<int>(N,-1);\n        }\n        int get(int x) {\n            if (e[x] < 0)\n                return x;\n            return e[x] = get(e[x]);\n        }\n        int size(int x) {\n            return -e[get(x)];\n        }\n        bool unite(int x, int y) {\n            x = get(x), y = get(y);\n            if (x == y)\n                return 0;\n            if (e[x] > e[y])\n                swap(x,y);\n            e[x] += e[y];\n            e[y] = x;\n            return 1;\n        }\n    };\n\n    int N, M;\n    vector<vector<char>> g;\n    vector<vector<bool>> visited;\n    vector<vector<DSU>> ds;\n    pair<int, int> bpos, spos, tpos;\n\n    int tto(int m, int n) { return m*N + n;  }\n    pair<int, int> ott(int i) { return {i / N, i % N};  }\n\n    vector<int> dx = {0, 1, 0, -1};\n    vector<int> dy = {1, 0, -1, 0};\n\n    void dfs(int i, int j, DSU& d) {\n        visited[i][j] = true;\n        for (int k=0; k<4; k++) {\n            int x = i + dx[k], y = j + dy[k];  \n            if (x >= 0 && x < M && y >= 0 && y < N && !visited[x][y] && g[x][y] != '#') {\n                d.unite(tto(i, j), tto(x, y));\n                dfs(x, y, d);\n            }\n        }\n    }\n    int BIGN = INT_MAX - 2e7;\n\n    vector<vector<unordered_map<int, int>>> memo, state;\n    // state: position of the box, region of the person (map) -> total pushes\n    int dp(int i, int j, int ci, int cj) { // worst case box splits into 4 positions\n        int leader = ds[i][j].get(tto(ci, cj));\n        if (state[i][j][leader] == 2) {\n            std::cout << \"A\";\n            return memo[i][j][leader]; \n        }\n        // if (i == bpos.first && j == bpos.second) {\n        //     std::cout << \"B\";\n        //     state[i][j][leader] = 2;\n        //     return memo[i][j][leader] = 0;\n        // } // base case\n        if (state[i][j][leader] == 1)\n            return BIGN;\n\n        state[i][j][leader] = 1;\n        \n        int ans = BIGN;\n        for (int k=0; k<4; k++) {\n            int bx = i - dx[k],  by = j - dy[k];      // previous box position\n            int x  = i - 2*dx[k], y  = j - 2*dy[k];   // previous player position\n    \n            if (bx < 0 || bx >= M || by < 0 || by >= N || g[bx][by] == '#')\n                continue;\n            if (x >= 0 && x < M && y >= 0 && y < N && \n                    g[x][y] != '#' && leader == ds[i][j].get(tto(bx, by))) {\n                ans = min(ans, dp(bx, by, x, y) + 1);\n            }\n        }\n        ans = min(ans, BIGN);\n        state[i][j][leader] = 2;\n        if (ans == BIGN)\n            state[i][j][leader] = 0;\n        std::cout << \"C\";\n        return memo[i][j][leader] = ans;\n    }\n        \n    int minPushBox(vector<vector<char>>& grid) {\n        // idea: disjoint set union, to figure out connected spaces\n\n        M = (int)grid.size();\n        N = (int)grid[0].size();\n        g = grid;\n\n        ds = vector<vector<DSU>> (M, vector<DSU> (N));\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (g[i][j] != '#') {\n                    ds[i][j].init(M*N);\n                    char orig = g[i][j];\n                    g[i][j] = '#';\n\n                    visited = vector<vector<bool>>(M, vector<bool>(N, false));\n                    for (int x=0; x<M; x++)\n                        for (int y=0; y<N; y++)\n                            if (!visited[x][y] && g[x][y] != '#')\n                                dfs(x, y, ds[i][j]);\n                    g[i][j] = orig;\n                }\n                if (g[i][j] == 'S')\n                    spos = {i, j};\n                if (g[i][j] == 'B')\n                    bpos = {i, j};\n                if (g[i][j] == 'T')\n                    tpos = {i, j};\n            }\n        }\n        memo = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n        state = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n\n        int leader = ds[bpos.first][bpos.second].get(tto(spos.first, spos.second));\n        memo[bpos.first][bpos.second][leader] = 0;\n        state[bpos.first][bpos.second][leader] = 2;\n        int ret = dp(tpos.first, tpos.second, spos.first, spos.second);\n\nstd::cout << endl;\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (g[i][j] == '#') {\n                    cout << setw(5) << \"-1\";\n                    continue;\n                }\n\n                for (int m=0; m<M; m++)\n                    for (int n=0; n<N; n++)\n                        if (g[m][n] != '#') {\n\n                            int leader = ds[i][j].get(tto(m, n));\n                            if (memo[i][j].count(leader))\n                                cout << setw(5) << (memo[i][j][leader] == BIGN ? -2 : memo[i][j][leader]) << \"\";\n                            else\n                                cout << setw(5) << \"-1\";\n                                \n                            m=M, n=N;\n                        }\n\n\n            }\n            cout << endl;\n        }\n\n        return (ret == BIGN ? -1 : ret);\n    }\n};\n/*\n\n [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\"#\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\"T\",\".\",\".\",\".\",\".\",\".\",\"#\"],\n  [\"#\",\".\",\".\",\".\",\"#\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n  [\".\",\".\",\"S\",\".\",\"B\",\".\",\".\",\".\"],\n  [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\n\n    0     0     0     0     0     0     0     0 \n    0    -2    -1     8     7     6     7     0 \n    0    11    10     9    -2     5     6    -1 \n    -1    -2    -2    -2   -1     4     5     0 \n    0     5     4     3     2     3     4     0 \n    0     4     3     2     1     2     3     0 \n    0    -2    -2     1     0     1     2     0 \n    0     0     0     0     0     0     0     0 \n\n   [[\"T\",\"B\",\".\"],\n    [\".\",\".\",\"#\"],\n    [\"S\",\".\",\"#\"]]\n\n    ds[0][1].e:\n    {-5, -1, -1, \n      0,  0, -1, \n      0,  0, -1}\n\n\n\n\n*/","compare_result":"111111111111111111101111111111","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1,"frontend_id":1149}