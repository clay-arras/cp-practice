{"id":1725069726,"question_id":1389,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754446732,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1725069726/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution {\npublic:\n    struct DSU {\n        vector<int> e;\n        void init(int N) {\n            e = vector<int>(N,-1);\n        }\n        int get(int x) {\n            if (e[x] < 0)\n                return x;\n            return e[x] = get(e[x]);\n        }\n        int size(int x) {\n            return -e[get(x)];\n        }\n        bool unite(int x, int y) {\n            x = get(x), y = get(y);\n            if (x == y)\n                return 0;\n            if (e[x] > e[y])\n                swap(x,y);\n            e[x] += e[y];\n            e[y] = x;\n            return 1;\n        }\n    };\n\n    int N, M;\n    vector<vector<char>> g;\n    vector<vector<bool>> visited;\n    vector<vector<DSU>> ds;\n    pair<int, int> bpos, spos, tpos;\n\n    int tto(int m, int n) { return m*N + n;  }\n    pair<int, int> ott(int i) { return {i / N, i % N};  }\n\n    vector<int> dx = {0, 1, 0, -1};\n    vector<int> dy = {1, 0, -1, 0};\n\n    // assume you can walk though T\n    void dfs(int i, int j, DSU& d) {\n        visited[i][j] = true;\n\n        for (int k=0; k<4; k++) {\n            int x = i + dx[k], y = j + dy[k];  \n            if (x >= 0 && x < M && y >= 0 && y < N && !visited[x][y] && g[x][y] != '#') {\n                d.unite(tto(i, j), tto(x, y));\n                dfs(x, y, d);\n            }\n        }\n    }\n    int BIGN = 2e9+1;\n\n    vector<vector<unordered_map<int, int>>> memo, state;\n    // state: position of the box, region of the person (map) -> total pushes\n    int dp(int i, int j, int ci, int cj) { // worst case box splits into 4 positions\n        int leader = ds[i][j].get(tto(ci, cj));\n        if (state[i][j][leader] == 2)\n            return memo[i][j][leader]; \n        if (i == bpos.first && j == bpos.second) {\n            // std::cout << memo[i][j][leader] << std::endl;\n            state[i][j][leader] = 2;\n            return memo[i][j][leader] = 0;\n        } // base case\n        if (state[i][j][leader] == 1)\n            return BIGN;\n\n        state[i][j][leader] = 1;\n        \n        int ans = BIGN;\n        for (int k=0; k<4; k++) {\n            int bx = i + dx[k], by = j + dy[k];   // where it was previously\n            int x = i + 2*dx[k], y = j + 2*dy[k];  // where s was previously\n            if (x >= 0 && x < M && y >= 0 && y < N && \n                    g[x][y] != '#' && leader == ds[i][j].get(tto(bx, by))) {\n                ans = min(ans, dp(bx, by, x, y) + 1);\n            }\n        }\n        state[i][j][leader] = 2;\n        return memo[i][j][leader] = ans;\n    }\n        \n    int minPushBox(vector<vector<char>>& grid) {\n        // idea: disjoint set union, to figure out connected spaces\n        // simplification: assume guy can teleport anywhere. in that case, it would be a simple graph search. connect node A to node B if there's a space behind it.\n\n        M = (int)grid.size();\n        N = (int)grid[0].size();\n        g = grid;\n\n        ds = vector<vector<DSU>> (M, vector<DSU> (N));\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (g[i][j] != '#') {\n                    ds[i][j].init(tto(M, N));\n                    char orig = g[i][j];\n                    g[i][j] = '#';\n\n                    visited = vector<vector<bool>>(M, vector<bool>(N, false));\n                    // flood fill\n                    for (int x=0; x<M; x++)\n                        for (int y=0; y<N; y++)\n                            if (!visited[x][y] && g[x][y] != '#')\n                                dfs(x, y, ds[i][j]);\n                    g[i][j] = orig;\n                }\n                if (g[i][j] == 'S')\n                    spos = {i, j};\n                if (g[i][j] == 'B')\n                    bpos = {i, j};\n                if (g[i][j] == 'T')\n                    tpos = {i, j};\n            }\n        }\n        memo = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n        state = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n\n        memo[bpos.first][bpos.second][tto(spos.first, spos.second)] = 0;\n        state[bpos.first][bpos.second][tto(spos.first, spos.second)] = 2;\n        int ret = dp(tpos.first, tpos.second, spos.first, spos.second);\n        return (ret == BIGN ? -1 : ret);\n    }\n};\n/*\n \n [[\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n  [\"#\",\".\",\".\",\"T\",\"#\",\".\",\".\",\"#\"],\n  [\"#\",\".\",\".\",\".\",\"#\",\"B\",\".\",\"#\"],\n  [\"#\",\".\",\".\",\".\",\".\",\".\",\".\",\"#\"],\n  [\"#\",\".\",\".\",\".\",\"#\",\".\",\"S\",\"#\"],\n  [\"#\",\".\",\".\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n\n  ds[3][3].e:\n  {-1, 27, 27, -1, -1, -1, -1, -1, \n   -1, 27, 27, 27, -1, 27, 27, -1, \n   -1, 27, 27, 27, -1, 27, 27, -1, \n   -1, 27, 27,-25, 27, 27, 27, -1,\n   -1, 27, 27, 27, -1, 27, 27, -1, \n   -1, 27, 27, -1, -1, -1, -1, -1, \n   -1, -1, -1, -1, -1, -1, -1, -1}\n\n   {-1,-25, 1, -1, -1, -1, -1, -1, \n    -1, 1, 1, 1, -1, 1,  1, -1, \n    -1, 1, 1, 1, -1, 1, 1, -1, -1,  \n    1,  1, 1, 1,  1, 1, -1, -1, 1,  \n    1, 1, -1, 1, 1, -1, -1, 1, 1, -1, \n     -1,-1, -1,-1,-1, -1,-1, -1,-1, -1, -1, -1}\n\n\n\n\n*/","compare_result":"111111110110100110001111011111","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1,"frontend_id":1142}