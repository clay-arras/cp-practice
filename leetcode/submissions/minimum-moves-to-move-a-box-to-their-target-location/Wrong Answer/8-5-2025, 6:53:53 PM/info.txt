{"id":1725056415,"question_id":1389,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754445233,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1725056415/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution {\npublic:\n    struct DSU {\n        vector<int> e;\n        void init(int N) {\n            e = vector<int>(N,-1);\n        }\n        int get(int x) {\n            if (e[x] < 0)\n                return x;\n            return e[x] = get(e[x]);\n        }\n        int size(int x) {\n            return -e[get(x)];\n        }\n        bool unite(int x, int y) {\n            x = get(x), y = get(y);\n            if (x == y)\n                return 0;\n            if (e[x] > e[y])\n                swap(x,y);\n            e[x] += e[y];\n            e[y] = x;\n            return 1;\n        }\n    };\n\n    int N, M;\n    vector<vector<char>> g;\n    vector<vector<bool>> visited;\n    vector<vector<DSU>> ds;\n    pair<int, int> bpos, spos, tpos;\n\n    int tto(int m, int n) { return m*N + n;  }\n    pair<int, int> ott(int i) { return {i / N, i % N};  }\n\n    vector<int> dx = {0, 1, 0, -1};\n    vector<int> dy = {1, 0, -1, 0};\n\n    // assume you can walk though T\n    void dfs(int i, int j, DSU& d) {\n        visited[i][j] = true;\n\n        for (int k=0; k<4; k++) {\n            int x = i + dx[k], y = j + dy[k];  \n            if (x >= 0 && x < M && y >= 0 && y < N && !visited[x][y] && g[x][y] != '#') {\n                d.unite(tto(i, j), tto(x, y));\n                dfs(x, y, d);\n            }\n        }\n    }\n    vector<vector<unordered_map<int, int>>> memo;\n    // state: position of the box, region of the person (map) -> total pushes\n    void dp(int i, int j, int ci, int cj) { // worst case box splits into 4 positions\n        int leader = ds[i][j].get(tto(ci, cj));\n        // if (memo[i][j].count(leader) && (i != bpos.first || j != bpos.second ))\n            // return memo[i][j][leader]; \n        if (!memo[i][j].count(leader))\n            return;\n        \n        int ans = 1e9+7;\n        for (int k=0; k<4; k++) {\n            int fx = i + dx[k], fy = j + dy[k]; // future pos\n            int x = i - dx[k], y = j - dy[k]; // where s goes\n            if (x >= 0 && x < M && y >= 0 && y < N && \n                    g[fx][fy] != '#' && leader == ds[i][j].get(tto(x, y))) {\n                // ans = min(ans, dp(fx, fy, i, j) + 1);\n\n                if (!memo[fx][fy].count(tto(i, j)))\n                    memo[fx][fy][tto(i, j)] = 1 + memo[i][j][leader];\n                else\n                    memo[fx][fy][tto(i, j)] = min(memo[fx][fy][tto(i, j)], 1 + memo[i][j][leader]);\n                dp(fx, fy, i, j);\n            }\n        }\n        return;\n    }\n        \n    int minPushBox(vector<vector<char>>& grid) {\n        // idea: disjoint set union, to figure out connected spaces\n        // simplification: assume guy can teleport anywhere. in that case, it would be a simple graph search. connect node A to node B if there's a space behind it.\n\n        M = (int)grid.size();\n        N = (int)grid[0].size();\n        g = grid;\n\n        ds = vector<vector<DSU>> (M, vector<DSU> (N));\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (grid[i][j] != '#') {\n                    ds[i][j].init(tto(M, N));\n                    char orig = grid[i][j];\n                    grid[i][j] = '#';\n\n                    visited = vector<vector<bool>>(M, vector<bool>(N, false));\n                    // flood fill\n                    dfs(i, j, ds[i][j]);\n                    grid[i][j] = orig;\n                }\n                if (grid[i][j] == 'S')\n                    spos = {i, j};\n                if (grid[i][j] == 'B')\n                    bpos = {i, j};\n                if (grid[i][j] == 'T')\n                    tpos = {i, j};\n            }\n        }\n        memo = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n        int leader = ds[bpos.first][bpos.second].get(tto(spos.first, spos.second));\n        memo[bpos.first][bpos.second][leader] = 0;\n\n        dp(bpos.first, bpos.second, spos.first, spos.second);\n\n        int ans = INT_MAX;\n        for (int i=0; i<M; i++)\n            for (int j=0; j<N; j++)\n                if (memo[tpos.first][tpos.second].count(tto(i, j)))\n                    ans = min(ans, memo[tpos.first][tpos.second][tto(i, j)]);\n        return (ans == INT_MAX ? -1 : ans);\n    }\n};\n\n\n/*\nfeed forward: assume this state is covered, calculate next states\n\n*/","compare_result":"010100000000000100000000000000","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1,"frontend_id":1140}