{"id":1726057440,"question_id":1389,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754504611,"status":10,"status_display":"Accepted","runtime":"67 ms","url":"/submissions/detail/1726057440/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"16.3 MB","code":"class Solution {\npublic:\n    struct DSU {\n        vector<int> e;\n        void init(int N) {\n            e = vector<int>(N,-1);\n        }\n        int get(int x) {\n            if (e[x] < 0)\n                return x;\n            return e[x] = get(e[x]);\n        }\n        int size(int x) {\n            return -e[get(x)];\n        }\n        bool unite(int x, int y) {\n            x = get(x), y = get(y);\n            if (x == y)\n                return 0;\n            if (e[x] > e[y])\n                swap(x,y);\n            e[x] += e[y];\n            e[y] = x;\n            return 1;\n        }\n    };\n\n    int N, M;\n    vector<vector<char>> g;\n    vector<vector<bool>> visited;\n    vector<vector<DSU>> ds;\n    pair<int, int> bpos, spos, tpos;\n\n    int tto(int m, int n) { return m*N + n;  }\n    pair<int, int> ott(int i) { return {i / N, i % N};  }\n\n    vector<int> dx = {0, 1, 0, -1};\n    vector<int> dy = {1, 0, -1, 0};\n\n    void dfs(int i, int j, DSU& d) {\n        visited[i][j] = true;\n        for (int k=0; k<4; k++) {\n            int x = i + dx[k], y = j + dy[k];  \n            if (x >= 0 && x < M && y >= 0 && y < N && !visited[x][y] && g[x][y] != '#') {\n                d.unite(tto(i, j), tto(x, y));\n                dfs(x, y, d);\n            }\n        }\n    }\n    int BIGN = INT_MAX - 2e7;\n\n    vector<vector<unordered_map<int, int>>> memo, state;\n    int dp(int i, int j, int ci, int cj) { \n        int leader = ds[i][j].get(tto(ci, cj));\n        if (state[i][j][leader] == 2) {\n            return memo[i][j][leader]; \n        }\n        if (state[i][j][leader] == 1)\n            return BIGN;\n\n        state[i][j][leader] = 1;\n        \n        int ans = BIGN;\n        for (int k=0; k<4; k++) {\n            int bx = i - dx[k],  by = j - dy[k];\n            int x  = i - 2*dx[k], y  = j - 2*dy[k];\n    \n            if (bx < 0 || bx >= M || by < 0 || by >= N || g[bx][by] == '#')\n                continue;\n            if (x >= 0 && x < M && y >= 0 && y < N && \n                    g[x][y] != '#' && leader == ds[i][j].get(tto(bx, by))) {\n                ans = min(ans, dp(bx, by, x, y) + 1);\n            }\n        }\n        ans = min(ans, BIGN);\n        state[i][j][leader] = 2;\n        if (ans == BIGN)\n            state[i][j][leader] = 0;\n        return memo[i][j][leader] = ans;\n    }\n        \n    int minPushBox(vector<vector<char>>& grid) {\n        M = (int)grid.size();\n        N = (int)grid[0].size();\n        g = grid;\n\n        ds = vector<vector<DSU>> (M, vector<DSU> (N));\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (g[i][j] != '#') {\n                    ds[i][j].init(M*N);\n                    char orig = g[i][j];\n                    g[i][j] = '#';\n\n                    visited = vector<vector<bool>>(M, vector<bool>(N, false));\n                    for (int x=0; x<M; x++)\n                        for (int y=0; y<N; y++)\n                            if (!visited[x][y] && g[x][y] != '#')\n                                dfs(x, y, ds[i][j]);\n                    g[i][j] = orig;\n                }\n                if (g[i][j] == 'S')\n                    spos = {i, j};\n                if (g[i][j] == 'B')\n                    bpos = {i, j};\n                if (g[i][j] == 'T')\n                    tpos = {i, j};\n            }\n        }\n        memo = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n        state = vector<vector<unordered_map<int, int>>>(M, vector<unordered_map<int, int>>(N));\n\n        int leader = ds[bpos.first][bpos.second].get(tto(spos.first, spos.second));\n        memo[bpos.first][bpos.second][leader] = 0;\n        state[bpos.first][bpos.second][leader] = 2;\n        int ret = BIGN;\n        for (int i=0; i<M; i++)\n            for (int j=0; j<N; j++)\n                if (ds[bpos.first][bpos.second].get(tto(i, j)) == tto(i, j)) {\n                    ret = min(ret, dp(tpos.first, tpos.second, i, j));\n                }\n\n        std::cout << endl;\n        for (int i=0; i<M; i++) {\n            for (int j=0; j<N; j++) {\n                if (g[i][j] == '#') {\n                    cout << setw(5) << \"-1\";\n                    continue;\n                }\n\n                for (int m=0; m<M; m++)\n                    for (int n=0; n<N; n++)\n                        if (g[m][n] != '#') {\n\n                            int leader = ds[i][j].get(tto(m, n));\n                            if (memo[i][j].count(leader))\n                                cout << setw(5) << (memo[i][j][leader] == BIGN ? -2 : memo[i][j][leader]) << \"\";\n                            else\n                                cout << setw(5) << \"-1\";\n                                \n                            m=M, n=N;\n                        }\n\n\n            }\n            cout << endl;\n        }\n\n        return (ret == BIGN ? -1 : ret);\n    }\n};\n/*\n\n      [[\".\",\".\",\".\"],\n       [\".\",\".\",\".\"],\n       [\"#\",\"B\",\".\"],\n       [\"S\",\"T\",\"#\"]]\n\n\nds[2][1].e:{-7, 0, 0, \n             0, 0, 0, \n            -1, -1, 0,\n            -2, 9, -1}\n\n\n\n\n\n*/","compare_result":"111111111111111111111111111111","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":null,"flag_type":1,"frontend_id":1150}