{"id":1731316844,"question_id":2703,"lang":"cpp","lang_name":"C++","time":"3 months, 1 week","timestamp":1754922446,"status":10,"status_display":"Accepted","runtime":"146 ms","url":"/submissions/detail/1731316844/","is_pending":"Not Pending","title":"Handling Sum Queries After Update","memory":"135.1 MB","code":"class Solution {\npublic:\n    template<class T, int SZ>\n    struct LazySeg {\n        static_assert(__builtin_popcount(SZ) == 1);\n        const T ID{};\n        T cmb(T a, T b) { return a+b; }\n        T seg[2*SZ], lazy[2*SZ];\n        LazySeg() {\n            for (int i=0; i<2*SZ; i++)\n                seg[i] = lazy[i] = ID;\n        }\n        void push(int ind, int L, int R) {\n            if (lazy[ind] == 1)\n                seg[ind] = (R-L+1) - seg[ind]; // here: seg[ind] += (R-L+1)*lazy[ind];\n            if (L != R) {\n                for (int i=0; i<2; ++i)\n                    lazy[2*ind+i] ^= lazy[ind]; // here: lazy[2*ind+i] += lazy[ind];\n            }\n            lazy[ind] = 0;\n        }\n        void pull(int ind){\n            seg[ind]=cmb(seg[2*ind],seg[2*ind+1]);\n        }\n        void build() {\n            for (int i=SZ-1; i>=1; --i)\n                pull(i);\n        }\n        void update(int lo,int hi,T inc,int ind=1,int L=0, int R=SZ-1) {\n            push(ind,L,R); \n            if (hi < L || R < lo) return;\n            if (lo <= L && R <= hi) {\n                lazy[ind] = inc;\n                push(ind,L,R);\n                return;\n            }\n            int M = (L+R)/2;\n            update(lo,hi,inc,2*ind,L,M);\n            update(lo,hi,inc,2*ind+1,M+1,R);\n            pull(ind);\n        }\n        T query(int lo, int hi, int ind=1, int L=0, int R=SZ-1) {\n            push(ind,L,R);\n            if (lo > R || L > hi) return ID;\n            if (lo <= L && R <= hi) return seg[ind];\n            int M = (L+R)/2;\n            return cmb(query(lo,hi,2*ind,L,M), query(lo,hi,2*ind+1,M+1,R));\n        }\n    };\n\n    vector<long long> handleQuery(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\n        int N = (int)nums1.size();\n        \n        vector<long long> ans;\n        const int SZ = (1 << 18);\n        LazySeg<long long, SZ> s;\n        \n        for (int i=SZ; i<SZ+N; i++)\n            s.seg[i] = nums1[i-SZ];\n        s.build();\n\n        long long sum = 0;\n        for (int i : nums2)\n            sum += i;\n        for (auto q : queries) {\n            if (q[0] == 1) {\n                s.update(q[1], q[2], 1);\n            } else if (q[0] == 2) {\n                sum += s.query(0, N-1) * q[1]; \n            } else if (q[0] == 3) {\n                ans.push_back(sum);\n            }\n        }\n        return ans;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"handling-sum-queries-after-update","has_notes":null,"flag_type":1,"frontend_id":1157}