{"id":1780492654,"question_id":4007,"lang":"cpp","lang_name":"C++","time":"1 month, 3 weeks","timestamp":1758650652,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1780492654/","is_pending":"Not Pending","title":"Maximum Total Subarray Value II","memory":"N/A","code":"class Solution {\npublic:\n    template<class T>\n    struct RMinQ {\n        vector<T> v; vector<vector<int>> jmp;\n        int level(int x) { return 31-__builtin_clz(x); }\n        int cmb(int a, int b) {\n            if (v[a] == v[b])\n                return min(a, b);\n            return v[a] < v[b] ? a : b;\n        }\n        void init(const vector<T>& _v) {\n            int sz = (int)_v.size();\n            jmp = { vector<int>(sz) };\n            v = _v;\n            iota(jmp[0].begin(), jmp[0].end(), 0);\n            for (int j=1; (1<<j)<=sz; j++) {\n                jmp.push_back(vector<int>(sz-(1<<j)+1));\n                for (int i=0; i<(int)jmp[j].size(); i++)\n                    jmp[j][i] = cmb(jmp[j-1][i], jmp[j-1][i+(1<<(j-1))]);\n            }\n        }\n        int index(int l, int r) {\n            int d = level(r-l+1);\n            assert(l <= r);\n            return cmb(jmp[d][l], jmp[d][r-(1<<d)+1]);\n        }\n        T query(int l, int r) { return v[index(l,r)]; }\n    };\n    \n    template<class T>\n    struct RMaxQ {\n        vector<T> v; vector<vector<int>> jmp;\n        int level(int x) { return 31-__builtin_clz(x); }\n        int cmb(int a, int b) {\n            if (v[a] == v[b])\n                return max(a, b);\n            return v[a] > v[b] ? a : b;\n        }\n        void init(const vector<T>& _v) {\n            int sz = (int)_v.size();\n            jmp = { vector<int>(sz) };\n            v = _v;\n            iota(jmp[0].begin(), jmp[0].end(), 0);\n            for (int j=1; (1<<j)<=sz; j++) {\n                jmp.push_back(vector<int>(sz-(1<<j)+1));\n                for (int i=0; i<(int)jmp[j].size(); i++)\n                    jmp[j][i] = cmb(jmp[j-1][i], jmp[j-1][i+(1<<(j-1))]);\n            }\n        }\n        int index(int l, int r) {\n            int d = level(r-l+1);\n            assert(l <= r);\n            return cmb(jmp[d][l], jmp[d][r-(1<<d)+1]);\n        }\n        T query(int l, int r) { return v[index(l,r)]; }\n    };\n\n    long long maxTotalValue(vector<int>& nums, int k) {\n        int N = (int)nums.size();\n\n        vector<pair<int, int>> srt;\n        for (int i=0; i<N; i++)\n            srt.push_back({nums[i], i});\n        vector<pair<int, int>> arr(srt.begin(), srt.end());\n        sort(srt.begin(), srt.end());\n        \n        RMaxQ<pair<int, int>> mxr; \n        mxr.init(arr);\n        RMinQ<pair<int, int>> mnr; \n        mnr.init(arr);\n        \n        long long ans = 0;\n        int mnb = 0, mxb = N-1;\n        bool sil = true; // small is left\n\n        for (int sel=0; sel!=k; ) {\n            pair<int, int> mn = mnr.query(mnb + sil*(bool)sel, mxb - !sil*(bool)sel);\n            pair<int, int> mx = mxr.query(mnb + !sil*(bool)sel, mxb - sil*(bool)sel);\n            if (mx.first <= mn.first)\n                break;\n\n            int nmnb = min(mn.second, mx.second);\n            int nmxb = max(mn.second, mx.second);\n            // cout << nmnb << \" \" << nmxb << endl;\n            int cnt = min((nmnb - mnb + 1) * (mxb - nmxb + 1), k - sel);\n            // cout << cnt << endl;\n            // cout << mx.first << \" \" << mn.first << endl;\n            ans += cnt * (mx.first - mn.first);\n            sel += cnt;\n            \n            mnb = nmnb, mxb = nmxb;\n            sil = (mn.second < mx.second);\n        }\n        \n        return ans;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111010011100111001110010100111001111011100111101000011100111001110011100111101110011100111001000011110111001110011110111001110011100111001111111100100001111011111111111100011100111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"maximum-total-subarray-value-ii","has_notes":false,"flag_type":1,"frontend_id":1209}