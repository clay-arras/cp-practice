{"id":1780538766,"question_id":4007,"lang":"cpp","lang_name":"C++","time":"1 month, 3 weeks","timestamp":1758653226,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1780538766/","is_pending":"Not Pending","title":"Maximum Total Subarray Value II","memory":"N/A","code":"/*\ncounter examples: \n\nnums = [18,36,6]\nk = 3\n\nwe never cover the subarray [18, 36] because of our greedy\n\n\n*/\n\n\nclass Solution {\npublic:\n    template<class T>\n    struct RMinQ {\n        vector<T> v; vector<vector<int>> jmp;\n        int level(int x) { return 31-__builtin_clz(x); }\n        int cmb(int a, int b) {\n            if (v[a] == v[b])\n                return min(a, b);\n            return v[a] < v[b] ? a : b;\n        }\n        void init(const vector<T>& _v) {\n            int sz = (int)_v.size();\n            jmp = { vector<int>(sz) };\n            v = _v;\n            iota(jmp[0].begin(), jmp[0].end(), 0);\n            for (int j=1; (1<<j)<=sz; j++) {\n                jmp.push_back(vector<int>(sz-(1<<j)+1));\n                for (int i=0; i<(int)jmp[j].size(); i++)\n                    jmp[j][i] = cmb(jmp[j-1][i], jmp[j-1][i+(1<<(j-1))]);\n            }\n        }\n        int index(int l, int r) {\n            int d = level(r-l+1);\n            assert(l <= r);\n            return cmb(jmp[d][l], jmp[d][r-(1<<d)+1]);\n        }\n        T query(int l, int r) { return v[index(l,r)]; }\n    };\n    \n    template<class T>\n    struct RMaxQ {\n        vector<T> v; vector<vector<int>> jmp;\n        int level(int x) { return 31-__builtin_clz(x); }\n        int cmb(int a, int b) {\n            if (v[a] == v[b])\n                return max(a, b);\n            return v[a] > v[b] ? a : b;\n        }\n        void init(const vector<T>& _v) {\n            int sz = (int)_v.size();\n            jmp = { vector<int>(sz) };\n            v = _v;\n            iota(jmp[0].begin(), jmp[0].end(), 0);\n            for (int j=1; (1<<j)<=sz; j++) {\n                jmp.push_back(vector<int>(sz-(1<<j)+1));\n                for (int i=0; i<(int)jmp[j].size(); i++)\n                    jmp[j][i] = cmb(jmp[j-1][i], jmp[j-1][i+(1<<(j-1))]);\n            }\n        }\n        int index(int l, int r) {\n            int d = level(r-l+1);\n            assert(l <= r);\n            return cmb(jmp[d][l], jmp[d][r-(1<<d)+1]);\n        }\n        T query(int l, int r) { return v[index(l,r)]; }\n    };\n\n    long long maxTotalValue(vector<int>& nums, int k) {\n        int N = (int)nums.size();\n\n        vector<pair<int, int>> srt;\n        for (int i=0; i<N; i++)\n            srt.push_back({nums[i], i});\n        vector<pair<int, int>> arr(srt.begin(), srt.end());\n        sort(srt.begin(), srt.end());\n        \n        RMaxQ<pair<int, int>> mxr; \n        mxr.init(arr);\n        RMinQ<pair<int, int>> mnr; \n        mnr.init(arr);\n        \n        long long ans = 0;\n        int mnb = 0, mxb = N-1;\n        bool sil = true; // small is left\n\n        for (int sel=0; sel!=k; ) {\n            // min is guaranteed to be diff, max can be same\n            pair<int, int> mn_n = mnr.query(mnb + sil*(bool)sel, mxb - !sil*(bool)sel); \n            pair<int, int> mx_n = mxr.query(mnb, mxb);\n            // rev\n            pair<int, int> mn_x = mnr.query(mnb, mxb);\n            pair<int, int> mx_x = mxr.query(mnb + !sil*(bool)sel, mxb - sil*(bool)sel);\n\n            pair<int, int> mn, mx;\n            if (mn_n == mn_x && mx_n == mx_x) {\n                mn = mn_n;\n                mx = mx_n;\n            } else if (mx_n.first - mn_n.first >= mx_x.first - mn_x.first) {\n                mn = mn_n;\n                mx = mx_n;\n            } else {\n                mn = mn_x;\n                mx = mx_x;\n            }\n\n            if (mx.first <= mn.first)\n                break;\n\n            int nmnb = min(mn.second, mx.second);\n            int nmxb = max(mn.second, mx.second);\n            // cout << nmnb << \" \" << nmxb << endl;\n\n            int cnt = min((nmnb - mnb + 1) * (mxb - nmxb + 1), k - sel);\n            if ((nmnb == mnb || nmxb == mxb) && sel)\n                cnt = min(max(nmnb - mnb, 1) * max(mxb - nmxb, 1), k - sel);\n            ans += cnt * (mx.first - mn.first);\n            sel += cnt;\n            \n            mnb = nmnb, mxb = nmxb;\n            sil = (mn.second < mx.second);\n        }\n        \n        return ans;\n    }\n};\n\n/*\nproblem: we don't NEED to move both bounds; we only need to move ONE. \nso we have to test the two different bound movements\n- if they're different, then we need to check which one yields a greater difference\n- in case of a tie, then we choose a random one\n\n*/","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111100111001110011100111001111011100111101110011100111001110011100111101110011100111001110011110111001110011110111001110011100111001111111100111001111111111111111110011110111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"maximum-total-subarray-value-ii","has_notes":false,"flag_type":1,"frontend_id":1212}