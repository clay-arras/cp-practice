{"id":1593799568,"question_id":3765,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1743558188,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1593799568/","is_pending":"Not Pending","title":"Minimum Cost to Divide Array Into Subarrays","memory":"N/A","code":"class Solution {\npublic:\n    vector<int> pref, costPref;\n\n    int dp(int i, int k, )\n\n    long long minimumCost(vector<int>& nums, vector<int>& cost, int k) {\n        // prefix sum, dp\n        // for i -> N\n        // then go BACK\n\n        // dp[i][k], we're on the ith value in the kth subarray\n        // either: add i to the kth subarray, OR start a new subarray\n\n        int N = (int)nums.size();\n        pref = vector<int> (N+1, 0); \n        costPref = vector<int> (N+1, 0); \n        \n        for (int i=0; i<N; i++) {\n            pref[i+1] += pref[i] + nums[i];\n            costPref[i+1] += costPref[i] + cost[i];\n        }\n        \n    }\n};\n/*\n\ndp[i][k] fill w/ INT_MAX\nfor (int i=0; i<N; i++) {\n    for (int j=i; j>=1; j++) \n    \n}\n\ntwo ends of the dp, l and r\ndp[i][k] = max(dp[i][k], dp[i-j][k-1] + (pref[i+1] + K * k) * (costPref[i+1] - costPref[i-j]); \n\nidea: the only variables are just i and j, we don't need to keep track of K.\ntwo choices when processing the ith value: \n*/","compare_result":null,"title_slug":"minimum-cost-to-divide-array-into-subarrays","has_notes":false,"flag_type":1,"frontend_id":1094}