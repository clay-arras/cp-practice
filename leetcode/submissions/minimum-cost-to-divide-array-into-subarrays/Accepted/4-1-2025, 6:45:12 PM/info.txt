{"id":1593800871,"question_id":3765,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1743558312,"status":10,"status_display":"Accepted","runtime":"411 ms","url":"/submissions/detail/1593800871/","is_pending":"Not Pending","title":"Minimum Cost to Divide Array Into Subarrays","memory":"350.1 MB","code":"class Solution {\npublic:\n    long long minimumCost(vector<int>& nums, vector<int>& cost, int k) {\n        int n = nums.size();\n        vector<long long> prefixNums(n, 0), prefixCosts(n, 0);\n        \n        // Build prefix sum for nums\n        prefixNums[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            prefixNums[i] = prefixNums[i - 1] + nums[i];\n        }\n        \n        // Build prefix sum for cost\n        prefixCosts[0] = cost[0];\n        for (int i = 1; i < n; i++) {\n            prefixCosts[i] = prefixCosts[i - 1] + cost[i];\n        }\n        \n        // dp[i][j] will store the minimum cost for partitioning the subarray starting at i and ending at j\n        // Use -1 to indicate an uncomputed state.\n        vector<vector<long long>> dp(n, vector<long long>(n, -1));\n        \n        long long ans = solve(0, 0, k, prefixNums, prefixCosts, dp);\n        return ans;\n    }\n    \nprivate:\n    long long solve(int start, int end, int k,\n                    const vector<long long>& prefixNums,\n                    const vector<long long>& prefixCosts,\n                    vector<vector<long long>>& dp) {\n        int n = prefixNums.size();\n        \n        // Base case: if we've reached the end of the array.\n        if (end == n) {\n            return (start == n) ? 0 : numeric_limits<long long>::max();\n        }\n        \n        // Return the result if already computed.\n        if (dp[start][end] != -1) {\n            return dp[start][end];\n        }\n        \n        // Compute the sum of the current subarray for nums and cost.\n        long long currentNumsSum = prefixNums[end];\n        long long currentCostSum = prefixCosts[n - 1];  // total sum of cost\n        if (start != 0) {\n            currentNumsSum = prefixNums[end] - prefixNums[start - 1];\n            currentCostSum = prefixCosts[n - 1] - prefixCosts[start - 1];\n        }\n        \n        // Compute the cost for the current subarray.\n        long long currentSubarrayCost = (currentNumsSum + k) * currentCostSum;\n        \n        // Option 1: cut the subarray here and add the cost of the next partition.\n        long long costIfCutHere = currentSubarrayCost;\n        long long nextCost = solve(end + 1, end + 1, k, prefixNums, prefixCosts, dp);\n        if (nextCost == numeric_limits<long long>::max())\n            costIfCutHere = numeric_limits<long long>::max();\n        else\n            costIfCutHere += nextCost;\n        \n        // Option 2: extend the current subarray to include the next element.\n        long long costIfExtend = solve(start, end + 1, k, prefixNums, prefixCosts, dp);\n        \n        // Choose the option with the minimum cost.\n        dp[start][end] = min(costIfCutHere, costIfExtend);\n        return dp[start][end];\n    }\n};\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-cost-to-divide-array-into-subarrays","has_notes":false,"flag_type":1,"frontend_id":1095}