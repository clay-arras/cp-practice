{"id":1487456080,"question_id":3439,"lang":"cpp","lang_name":"C++","time":"10 months, 3 weeks","timestamp":1735069340,"status":10,"status_display":"Accepted","runtime":"1781 ms","url":"/submissions/detail/1487456080/","is_pending":"Not Pending","title":"Find Minimum Diameter After Merging Two Trees","memory":"512.1 MB","code":"class Solution {\npublic:\n    unordered_map<int, vector<int>> adj_list;\n    unordered_map<int, bool> visited;\n    vector<int> pth;\n\n    pair<int, int> dfs1(int s, int dist) {\n        pair<int, int> ret = {dist, s};\n        visited[s] = true;\n        for (int i : adj_list[s]) {\n            if (!visited[i])\n                ret = max(ret, dfs1(i, dist+1));\n        }\n        return ret;\n    }\n\n    bool dfs2(int s, int en) {\n        visited[s] = true;\n        if (s == en) {\n            pth.push_back(s);\n            return true;\n        }\n        bool is_path = false;\n        for (int i : adj_list[s]) {\n            if (!visited[i])\n                is_path |= dfs2(i, en);\n        }\n        if (is_path) pth.push_back(s);\n        return is_path;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        if ((int)edges1.size() == 0 && (int)edges2.size() == 0)\n            return 1; \n\n        for (auto e : edges1) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n        for (auto e : edges2) {\n            adj_list[-e[0]-1].push_back(-e[1]-1);\n            adj_list[-e[1]-1].push_back(-e[0]-1);\n        }\n\n        int cn1 = 0, cn2 = -1;\n        pair<int, int> n1, n2;\n        const auto get_diameter_center = [&](int src) {\n            n1 = dfs1(src, 0);\n            visited.clear();\n            n2 = dfs1(n1.second, 0);\n            visited.clear();\n            dfs2(n1.second, n2.second);\n            visited.clear();\n            int ret = pth[(int)pth.size()/2];\n            pth.clear();\n            return ret;\n        };\n\n        if ((int)edges1.size() != 0) \n            cn1 = get_diameter_center(edges1[0][0]);\n        if ((int)edges2.size() != 0) \n            cn2 = get_diameter_center(-edges2[0][0]-1);\n\n        adj_list[cn1].push_back(cn2);\n        adj_list[cn2].push_back(cn1);\n\n        n1 = dfs1(cn1, 0);\n        visited.clear();\n        n2 = dfs1(n1.second, 0);\n        visited.clear();\n\n        return n2.first;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-minimum-diameter-after-merging-two-trees","has_notes":false,"flag_type":1,"frontend_id":991}