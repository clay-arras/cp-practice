{"id":1487453479,"question_id":3439,"lang":"cpp","lang_name":"C++","time":"10 months, 3 weeks","timestamp":1735069065,"status":10,"status_display":"Accepted","runtime":"1875 ms","url":"/submissions/detail/1487453479/","is_pending":"Not Pending","title":"Find Minimum Diameter After Merging Two Trees","memory":"512.1 MB","code":"class Solution {\npublic:\n    unordered_map<int, vector<int>> adj_list;\n    unordered_map<int, bool> visited;\n    vector<int> pth;\n\n    pair<int, int> dfs1(int s, int dist) {\n        pair<int, int> ret = {dist, s};\n        visited[s] = true;\n        for (int i : adj_list[s]) {\n            if (!visited[i])\n                ret = max(ret, dfs1(i, dist+1));\n        }\n        return ret;\n    }\n\n    bool dfs2(int s, int en) {\n        visited[s] = true;\n        if (s == en) {\n            pth.push_back(s);\n            return true;\n        }\n        bool is_path = false;\n        for (int i : adj_list[s]) {\n            if (!visited[i])\n                is_path |= dfs2(i, en);\n        }\n        if (is_path) pth.push_back(s);\n        return is_path;\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // basic algorithm: \n        // - find midpoint node of both trees\n        // - connect them\n        // - find diameter\n\n        // design: \n        // - one to find two diameter nodes and distance\n        // - one to find midpoint of two nodes\n\n        if ((int)edges1.size() == 0 && (int)edges2.size() == 0)\n            return 1; \n\n        for (auto e : edges1) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n        for (auto e : edges2) {\n            adj_list[-e[0]-1].push_back(-e[1]-1);\n            adj_list[-e[1]-1].push_back(-e[0]-1);\n        }\n\n        int cn1 = 0;\n        pair<int, int> n1, n2;\n        if ((int)edges1.size() != 0) {\n            n1 = dfs1(edges1[0][0], 0);\n            visited.clear();\n            n2 = dfs1(n1.second, 0);\n            visited.clear();\n            dfs2(n1.second, n2.second);\n            visited.clear();\n            cn1 = pth[(int)pth.size()/2];\n            pth.clear();\n        }\n\n        int cn2 = -1;\n        if ((int)edges2.size() != 0) {\n            n1 = dfs1(-edges2[0][0]-1, 0);\n            visited.clear();\n            n2 = dfs1(n1.second, 0);\n            visited.clear();\n            dfs2(n1.second, n2.second);\n            visited.clear();\n            cn2 = pth[(int)pth.size()/2];\n            pth.clear();\n        }\n\n        adj_list[cn1].push_back(cn2);\n        adj_list[cn2].push_back(cn1);\n\n        // cout << cn1 << \" \" << cn2 << endl;\n\n        n1 = dfs1(cn1, 0);\n        visited.clear();\n        n2 = dfs1(n1.second, 0);\n        visited.clear();\n\n        return n2.first;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-minimum-diameter-after-merging-two-trees","has_notes":false,"flag_type":1,"frontend_id":990}