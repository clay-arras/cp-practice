{"id":1487444471,"question_id":3439,"lang":"cpp","lang_name":"C++","time":"10 months, 3 weeks","timestamp":1735068145,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1487444471/","is_pending":"Not Pending","title":"Find Minimum Diameter After Merging Two Trees","memory":"N/A","code":"class Solution {\npublic:\n    unordered_map<int, vector<int>> adj_list;\n    unordered_map<int, bool> visited;\n    vector<int> pth;\n\n    pair<int, int> dfs1(int s, int dist) {\n        pair<int, int> ret = {dist, s};\n        visited[s] = true;\n        for (int i : adj_list[s]) {\n            if (!visited[i])\n                ret = max(ret, dfs1(i, dist+1));\n        }\n        return ret;\n    }\n\n    void dfs2(int s, int en, vector<int> path) {\n        path.push_back(s);\n        visited[s] = true;\n        if (s == en) \n            pth = path;\n        for (int i : adj_list[s]) {\n            if (!visited[i])\n                dfs2(i, en, path);\n        }\n    }\n\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1, vector<vector<int>>& edges2) {\n        // basic algorithm: \n        // - find midpoint node of both trees\n        // - connect them\n        // - find diameter\n\n        // design: \n        // - one to find two diameter nodes and distance\n        // - one to find midpoint of two nodes\n        if ((int)edges1.size() == 0 && (int)edges2.size() == 0)\n            return 1; \n\n        for (auto e : edges1) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n        for (auto e : edges2) {\n            adj_list[-e[0]-1].push_back(-e[1]-1);\n            adj_list[-e[1]-1].push_back(-e[0]-1);\n        }\n\n        int cn1 = 0;\n        pair<int, int> n1, n2;\n        if ((int)edges1.size() != 0) {\n            n1 = dfs1(edges1[0][0], 0);\n            visited.clear();\n            n2 = dfs1(n1.second, 0);\n            visited.clear();\n            dfs2(n1.second, n2.second, {});\n            visited.clear();\n            cn1 = pth[(int)pth.size()/2];\n            if ((int)edges2.size() == 0)\n                return n2.first + 1;\n        }\n\n        n1 = dfs1(edges2[0][0]-1, 0);\n        visited.clear();\n        n2 = dfs1(n1.second, 0);\n        visited.clear();\n        dfs2(n1.second, n2.second, {});\n        visited.clear();\n        int cn2 = pth[(int)pth.size()/2];\n        if ((int)edges1.size() == 0)\n            return n2.first + 1;\n\n        adj_list[cn1].push_back(cn2);\n        adj_list[cn2].push_back(cn1);\n\n        n1 = dfs1(cn1, 0);\n        visited.clear();\n        n2 = dfs1(n1.second, 0);\n        visited.clear();\n\n        return n2.first;\n    }\n};","compare_result":"111111011011001010010100011010110001000111111000110100100000110000000101000100000101001000010000001000000000101000001100000100001110000101000000100010000101100010010000001100100000001000001001110101110010000110000000010110001000110001010000000010010011001010010011010000111010010001001001001101010000001000001010001000011100001000100100001100000001000000100010101101110100101000000000100000001000100111001001110100010100001000101111100000000010001010001011000010000001011010100111101100100011000000100001101101000110110001010001101001100011010011000111111000010111010000100010100001010000000010000001111010000100001001111101100111100011100001001100001000001000100011000101101100001000110000001000011110101111010001001101100","title_slug":"find-minimum-diameter-after-merging-two-trees","has_notes":false,"flag_type":1,"frontend_id":987}