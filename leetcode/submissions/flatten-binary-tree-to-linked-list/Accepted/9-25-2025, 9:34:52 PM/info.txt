{"id":1782928137,"question_id":114,"lang":"cpp","lang_name":"C++","time":"1 month, 3 weeks","timestamp":1758861292,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1782928137/","is_pending":"Not Pending","title":"Flatten Binary Tree to Linked List","memory":"17.5 MB","code":"class Solution {\npublic:\n    TreeNode* lastNodeInChain;\n\n    void dfs(TreeNode* node, TreeNode* prev, bool isPrevLeftChild) {\n        if (node == nullptr)\n            return;\n\n        if (prev != nullptr) {\n            assert(lastNodeInChain->left == nullptr || lastNodeInChain->left == node);\n            lastNodeInChain->left = node;\n            if (lastNodeInChain != prev) {\n                if (isPrevLeftChild) \n                    prev->left = nullptr;\n                else prev->right = nullptr;\n            }\n        }\n        lastNodeInChain = node;\n\n        dfs(node->left, node, true);\n        dfs(node->right, node, false);\n        node->right = nullptr;\n    }\n    void flip(TreeNode* node) {\n        if (node == nullptr)\n            return;\n        swap(node->left, node->right);\n\n        flip(node->left);\n        flip(node->right);\n    }\n\n    void flatten(TreeNode* root) {\n        lastNodeInChain = nullptr;\n        dfs(root, nullptr, false);\n        lastNodeInChain = nullptr;\n        flip(root);\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flatten-binary-tree-to-linked-list","has_notes":null,"flag_type":1,"frontend_id":1214}